# Observer Pattern

> 한 객체의 상태가 바뀌면 그 객체가 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 **일대다 의존성**을 정의.

<br>

## 구조

<img src="https://github.com/shhhhhhhhhhhh/practice/blob/master/designPattern/res/observer_pattern.png?raw=true" alt="observer_pattern" />

- Subject: 주제를 나타내는 인터페이스. 객체에서 옵저버로 등록하거나 옵저버 목록에서 탈퇴하고 싶을 때는 Subject의 메소드를 사용. 각 주제마다 여러개의 옵저버가 있을 수 있다.
- Observer: 옵저버가 될 가능성이 있는 객체에서는 Observer 인터페이스를 구현해야 한다. 주제의 상태가 바뀌었을 때 호출되는 update() 메소드를 가진다.
- ConcreteSubject: 옵저버의 등록, 해제 및 상태 변경시 연락하는 메소드를 구현. (WeatherData)
  - 옵저버들의 목록을 가지고 있고 옵저버에 대해 등록, 해제, 연락이 가능하다.
  - 상태 변경시 각각의 옵저버들에게 update() 메소드를 호출하여 변경을 알린다.
- ConcreteObserver: Observer 인터페이스를 구현한다면 각 옵저버는 특정 주제 객체에 등록을 해서 연락 받을 수 있다. (XXXDisplay)
  - 객체 생성시 Subject를 받아 등록을 요청한다.
  - Subject가 notify() 호출시 데이터를 전달받아 변경하고 출력한다.

<br>

## 느슨한 결합

- 두 객체가 느슨하게 결합되어 있다는 것은, 그 둘이 상호작용을 하긴 하지만 서로에 대해 잘 알지 못한다는것을 의미한다.
- 옵저버 패턴에서는 주제와 옵저버가 느슨한게 결합되어 있는 객체 디자인을 제공한다.
  - 주제가 옵저버에 대해 아는것은 옵저버가 특정 인터페이스(Observer)를 구현 한다는 사실 뿐이다.
  - 옵저버는 언제든지 새로 추가 가능하다
  - 새로운 형식의 옵저버가 추가되어도 주제는 변경할 필요가 없다.
  - 주제나 옵저버가 바뀌어도 서로에게 영향을 미치지 않는다.

<br>

## 디자인 원칙

- 서로 상호작용 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
  - 느슨하게 결합하는 디자인을 사용하면 객체 사이의 상호 의존성을 최소화할 수 있기 때문에 변경 사항이 생겨도 무난히 처리할 수 있는 유연한 시스템을 구축할 수 있다.